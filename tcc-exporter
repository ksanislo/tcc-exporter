#!/usr/bin/env python3

import datetime
import codecs
import inspect
import json
import os
import re
import signal
import socket
import time
import urllib.parse
import urllib.request
import yaml

from http.cookiejar import LWPCookieJar
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.error import HTTPError

VERSION = '0.9.12'
CONFIG_FILE = os.environ.get('TCC_CONFIG_FILE', 'persistent/config.yml')
PREFIX = 'https://mytotalconnectcomfort.com/'

# Set your TCC_LOGLEVEL to either the string or index number for your base logging level.
LOGLEVELS = ['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG']


class Client(object):
  _backoff = 0
  _last_login = 0

  def __init__(self, username, password):
    global config
    self.cookiejar = LWPCookieJar(config['exporter.cookiejar'])
    self.username = username
    self.password = password
    self.urlopener = urllib.request.build_opener()
    self.urlopener.addheaders = [('User-Agent', 'tcc-exporter/'+VERSION)]
    try:
      log('DEBUG', 'Loading cookiejar: {0}'.format(config['exporter.cookiejar']))
      self.cookiejar.revert(ignore_discard=True, ignore_expires=False)
    except Exception as e:
      log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
    self.urlopener.add_handler(urllib.request.HTTPCookieProcessor(self.cookiejar))

  def login(self):
    form = {
      'UserName': self.username,
      'Password': self.password,
      'RememberMe': 'False'
    }
    headers = {
      'Origin': PREFIX + 'portal',
    }
    utc_seconds = time.mktime(time.gmtime())
    if (self._last_login + self._backoff <= utc_seconds):
      log('DEBUG', 'Attempting login to the TCC portal.')
      self._last_login = time.mktime(time.gmtime())
      data = urllib.parse.urlencode(form).encode('utf-8')
      request = urllib.request.Request(PREFIX + 'portal', data, headers)
      try:
        log('DEBUG', 'Remote GET: {0}'.format(PREFIX + 'portal'))
        self.urlopener.open(PREFIX + 'portal')  # get signin cookie
        log('DEBUG', 'Remote POST: {0}'.format(PREFIX + 'portal'))
        data = self.urlopener.open(request)  # actually sign in
        decoded = data.read().decode()
        if '/portal/Account/LogOff' in decoded:
          log('INFO', 'Portal login successful.')
          self._backoff = 0
          log('DEBUG', 'Saving cookiejar: {0}'.format(config['exporter.cookiejar']))
          self.cookiejar.save(ignore_discard=True, ignore_expires=False)
          return True
        log('WARNING', 'Portal login failed.')
        if (self._backoff < config['tcc.backoff']):
          self._backoff = config['tcc.backoff']
        elif (self._backoff * 2 > config['tcc.backoff_limit']):
          self._backoff = config['tcc.backoff_limit']
        else:
          self._backoff = self._backoff * 2
        if 'exceeded the maximum number of attempts' in decoded:
          log('WARNING', 'Portal said we have exceeded the maximum number of login attempts.')
          self._backoff = config['tcc.backoff_limit']
        log('INFO', 'Next login retry delayed {0} seconds.'.format(self._backoff))
        return False
      except Exception as e:
        log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
        return False
    else:
      log('DEBUG', 'Login retry delayed another {0} seconds.'.format(int(self._last_login + self._backoff - utc_seconds)))
      return False

  def _request(self, path, data={}, headers={}):
    if isinstance(data, str):
      data = data.encode('utf-8')
    elif isinstance(data, bytes):
      data = data
    elif data != {}:
      data = json.dumps(data).encode('utf-8')
    else:
      data = None
    headers = dict(headers)
    headers['X-Requested-With'] = 'XMLHttpRequest'
    headers['Accept'] = 'application/json, text/javascript'
    if data != None:
      headers['Content-Type'] = 'application/json; charset=utf-8'
    request = urllib.request.Request(PREFIX + path, data, headers)
    try:
      log('DEBUG', 'Remote GET: {0}'.format(PREFIX + path))
      return self.urlopener.open(request)  # actually fetch
    except HTTPError as e:
      log('INFO', 'Portal status: {0} - {1}'.format(e.code, e.reason))
      return e.code
    except socket.timeout as e:
      log('INFO', 'Portal status: 504 - Socket timeout')
      return 504
    except Exception as e:
      log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
      return 500

  def _request_data(self, path, data={}, headers={}):
    data = self._request(path, data, headers)
    if isinstance(data, int) and (data == 401): # Login failure, lets try to login again.
      if self.login():
        data = self._request(path, data, headers)
    if isinstance(data, int):
      return data # Another failure, just return the code.
    reader = codecs.getreader(data.headers.get_content_charset())
    try:
      retval = json.load(reader(data))
      self._backoff = 0 # We got decodable JSON, reset the backoff.
      if (os.path.getmtime(config['exporter.cookiejar']) + config['exporter.sync_interval'] <= time.time()):
        log('DEBUG', 'Saving cookiejar: {0}'.format(config['exporter.cookiejar']))
        self.cookiejar.save(ignore_discard=True, ignore_expires=False)
      return retval
    except json.JSONDecodeError as e:
      log('INFO', 'Portal returned invalid data.')
      return 502
    except Exception as e:
      log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
      return 500

  def locations(self):
    path = 'portal/Location/GetLocationListData?page=1&filter='
    data = self._request_data(path, '')
    return data
    
  def location_overview(self, locationId):
    path = 'portal/Device/GetZoneListData?locationId=%s&page=1' % (locationId,)
    data = self._request_data(path, '')
    return data

  def device_status(self, device_id):
    utc_milliseconds = int(round(time.time() * 1000))
    path = 'portal/Device/CheckDataSession/%s?_=%s' % (device_id, utc_milliseconds)
    data = self._request_data(path)
    return data


class Server(BaseHTTPRequestHandler):
  # Simplified logging
  def log_message(self, format, *args):
    log('DEBUG', 'Response status: {0}'.format(args[1]))

  def do_GET(self):
    log('DEBUG', 'Handling request: {0}'.format(self.requestline))
    results = bytes()
    for device in devices:
      data = client.device_status(device['DeviceID'])
      if isinstance(data, dict):
        results = results + do_stuff(device, device['DeviceID'], data).encode('utf-8')
    if results:
      self.send_response(200)
    elif isinstance(data, int):
      self.send_response(data)
    else:
      self.send_response(520) # Cloudflare's "520". No results, no idea why.
    self.send_header('Content-type','text/html')
    self.end_headers()
    if results:
      try:
        self.wfile.write(results)
      except BrokenPipeError as e:
        log('DEBUG', 'Prometheus closed the connection.')
      except Exception as e:
        log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
    return


def case_convert(name):
  string = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
  return re.sub('([a-z0-9])([A-Z])', r'\1_\2', string).lower()


def device_info(device):
  retval = str()
  for key in device:
    if retval:
      retval = retval + ','
    retval = retval + case_convert(key) + '="' + str(device[key]) + '"'
  return retval


def do_stuff(device, name, obj):
  retval = str()
  if isinstance(obj, dict):
    for each in obj:
      retval = retval + do_stuff(device, each, obj[each])
  if isinstance(obj, (int, bool)):
    if name not in device:
      retval = retval + '# HELP tcc_{0} Total_Control_Comfort value {1}\n'.format(case_convert(name), name)
      retval = retval + '# TYPE tcc_{0} gauge\n'.format(case_convert(name))
      retval = retval + 'tcc_{0}{{{1}}} {2}\n'.format(case_convert(name), device_info(device), int(obj))
  return retval
  

def log(level, *message):
  global config
  # If we were called with a descriptive string, find the index.
  if isinstance(level, str):
    level = LOGLEVELS.index(level)
  # TCC_LOGLEVEL can be either a text or a number.
  if config['log.level'].isdigit():
    debug_level = int(config['log.level'])
  else:
    debug_level = LOGLEVELS.index(config['log.level'].upper())
  if (level <= debug_level):
    print("[{0}] {1}".format(LOGLEVELS[level], " ".join(message)))


def hup_handler(signum, frame):
  load_config()
  find_devices()


def usr1_handler(signum, frame):
  log('DEBUG', 'Configuration dump:\n\n' + yaml.dump(config,default_flow_style = False))


def usr2_handler(signum, frame):
  global client
  client._backoff = 0
  client.login()


def find_devices():
  global devices
  devices = []
  try:
    for location in client.locations():
      for device in location['Devices']:
        log('INFO', 'DeviceID: {0}, LocationID: {1}, MacID: {2}, Name: {3}'.format(device['DeviceID'],device['LocationID'],device['MacID'],device['Name']))
        devices.append({ 'DeviceID': device['DeviceID'], 'LocationID': device['LocationID'], 'MacID': device['MacID'], 'Name': device['Name'] })
  except TypeError as e:
    log('CRITICAL', 'Failed to collect our list of known locations and devices. Aborting.')
    return
  except Exception as e:
    log('CRITICAL', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
    return


def load_config():
  global client, config
  if not 'config' in globals():
    config = {}
  if 'log.level' in config: # We can't log unless we know our level.
    log('DEBUG', 'Loading config: {0}'.format(CONFIG_FILE))
  # Load config file.
  try:
    with open(CONFIG_FILE, 'r') as cfile:
      config = yaml.load(cfile)
  except FileNotFoundError as e:
    log('ERROR', 'Config file {0} missing.'.format(CONFIG_FILE))
  except Exception as e:
    log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
  # Set defaults if missing.
  if not 'log.level' in config:
    config['log.level'] = 'INFO'
  if not 'tcc.timeout' in config:
    config['tcc.timeout'] = 10
  if not 'tcc.backoff' in config:
    config['tcc.backoff'] = 15
  if not 'tcc.backoff_limit' in config:
    config['tcc.backoff_limit'] = 300
  if not 'exporter.host' in config:
    config['exporter.host'] = '0.0.0.0'
  if not 'exporter.port' in config:
    config['exporter.port'] = 9101
  if not 'exporter.cookiejar' in config:
    config['exporter.cookiejar'] = 'persistent/cookies.txt'
  if not 'exporter.sync_interval' in config:
    config['exporter.sync_interval'] = 300
  if not 'config.override' in config:
    config['config.override'] = True
  # Override if allowed.
  if 'config.override' in config and config['config.override']:
    # Load environment settings 
    if os.environ.get('TCC_USERNAME'):
      config['tcc.username'] = os.environ.get('TCC_USERNAME')
    if os.environ.get('TCC_PASSWORD'):
      config['tcc.password'] = os.environ.get('TCC_PASSWORD')
    if os.environ.get('TCC_LOGLEVEL'):
      config['log.level'] = os.environ.get('TCC_LOGLEVEL')
    if os.environ.get('TCC_EXPORTER_PORT'):
      config['exporter.port'] = os.environ.get('TCC_EXPORTER_PORT')
    if os.environ.get('TCC_EXPORTER_COOKIEJAR'):
      config['exporter.cookiejar'] = os.environ.get('TCC_EXPORTER_COOKIEJAR')
  socket.setdefaulttimeout(int(config['tcc.timeout']))
  client = Client(config['tcc.username'], config['tcc.password'])


def main():
  global client, config, devices
  devices = []
  load_config()
  find_devices()
  log('INFO', 'tcc-exporter/{0} [pid: {1}]'.format(VERSION, os.getpid()))
  signal.signal(signal.SIGHUP, hup_handler)
  signal.signal(signal.SIGUSR1, usr1_handler)
  signal.signal(signal.SIGUSR2, usr2_handler)
  log('DEBUG', 'SIGHUP:reload config, SIGUSR1:show config, SIGUSR2: reattempt login')
  server_address=(config['exporter.host'], int(config['exporter.port']))
  httpd = HTTPServer(server_address, Server)
  log('INFO', 'Starting server: http://{0}:{1}'.format(server_address[0], server_address[1]))
  httpd.serve_forever()


if __name__ == '__main__':
  main()

