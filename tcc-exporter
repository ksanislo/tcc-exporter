#!/usr/bin/env python3

import codecs
import inspect
import json
import os
import re
import time
import urllib.parse
import urllib.request

from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.error import HTTPError

VERSION = '0.8.7'
PREFIX = 'https://mytotalconnectcomfort.com/'
devices = list()

# Set your TCC_LOGLEVEL to either the string or index number for your base logging level.
LOGLEVELS = ['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG']

class Client(object):
  _backoff = 0
  _last_login = 0
  _min_backoff = 15
  _max_backoff = 300

  def __init__(self, username, password):
    self.username = username
    self.password = password
    self.urlopener = urllib.request.build_opener()
    self.urlopener.addheaders = [('User-Agent', 'tcc-exporter/'+VERSION)]
    self.urlopener.add_handler(urllib.request.HTTPCookieProcessor())
    self.login()

  def login(self):
    form = {
      'UserName': self.username,
      'Password': self.password,
      'RememberMe': 'False'
    }
    headers = {
      'Origin': PREFIX + 'portal',
    }
    utc_seconds = time.mktime(time.gmtime())
    if (self._last_login + self._backoff <= utc_seconds):
      self._last_login = time.mktime(time.gmtime())
      data = urllib.parse.urlencode(form).encode('utf-8')
      request = urllib.request.Request(PREFIX + 'portal', data, headers)
      log('DEBUG', 'HTTP GET {0}'.format(PREFIX + 'portal'))
      self.urlopener.open(PREFIX + 'portal')  # get signin cookie
      try:
        log('DEBUG', 'HTTP POST {0}'.format(PREFIX + 'portal'))
        data = self.urlopener.open(request)  # actually sign in
        decoded = data.read().decode()
        if '/portal/Account/LogOff' in decoded:
          log('INFO', 'TCC portal login successful.')
          self._backoff = 0
          return True
        else:
          log('WARNING', 'TCC portal login failed.')
          if (self._backoff < self._min_backoff):
            self._backoff = self._min_backoff
          elif (self._backoff * 2 > self._max_backoff):
            self._backoff = self._max_backoff
          else:
            self._backoff = self._backoff * 2
          log('INFO', 'Set login retry delay to {0} seconds.'.format(self._backoff))
          return False
      except Exception as e:
        log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
        return False
    else:
      log('INFO', 'Login retry delayed another {0} seconds.'.format(int(self._last_login + self._backoff - utc_seconds)))
      return False

  def _request(self, path, data={}, headers={}):
    if isinstance(data, str):
      data = data.encode('utf-8')
    elif isinstance(data, bytes):
      data = data
    elif data != {}:
      data = json.dumps(data).encode('utf-8')
    else:
      data = None
    headers = dict(headers)
    headers['X-Requested-With'] = 'XMLHttpRequest'
    headers['Accept'] = 'application/json, text/javascript'
    if data != None:
      headers['Content-Type'] = 'application/json; charset=utf-8'
    request = urllib.request.Request(PREFIX + path, data, headers)
    try:
      log('DEBUG', 'HTTP GET {0}'.format(PREFIX + path))
      return self.urlopener.open(request)  # actually fetch
    except HTTPError as e:
      log('INFO', 'TCC portal status: {0} - {1}'.format(e.code, e.reason))
      return e.code
    except Exception as e:
      log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
      return 500

  def _request_data(self, path, data={}, headers={}):
    data = self._request(path, data, headers)
    if isinstance(data, int) and (data == 401): # Login failure, lets try to login again.
      if self.login():
        data = self._request(path, data, headers)
    if isinstance(data, int):
      return data # Another failure, just return the code.
    reader = codecs.getreader(data.headers.get_content_charset())
    try:
      retval = json.load(reader(data))
      self._backoff = 0 # We got decodable JSON, reset the backoff.
      return retval
    except json.JSONDecodeError as e:
      log('INFO', 'TCC portal returned invalid data.')
      return 502
    except Exception as e:
      log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
      return 500

  def locations(self):
    path = 'portal/Location/GetLocationListData?page=1&filter='
    data = self._request_data(path, '')
    return data
    
  def location_overview(self, locationId):
    path = 'portal/Device/GetZoneListData?locationId=%s&page=1' % (locationId,)
    data = self._request_data(path, '')
    return data

  def device_status(self, device_id):
    utc_milliseconds = int(round(time.time() * 1000))
    path = 'portal/Device/CheckDataSession/%s?_=%s' % (device_id, utc_milliseconds)
    data = self._request_data(path)
    return data


class Server(BaseHTTPRequestHandler):
  # Simplified logging
  def log_message(self, format, *args):
    log('DEBUG', format % args)

  def do_GET(self):
    results = bytes()
    for device in devices:
      data = client.device_status(device['DeviceID'])
      if isinstance(data, dict):
        results = results + do_stuff(device, device['DeviceID'], data).encode('utf-8')
    if results:
      self.send_response(200)
    elif isinstance(data, int):
      self.send_response(data)
    else:
      self.send_response(520) # Cloudflare's "520". No results, no idea why.
    self.send_header('Content-type','text/html')
    self.end_headers()
    if results:
      try:
        self.wfile.write(results)
      except BrokenPipeError as e:
        log('DEBUG', 'Prometheus closed the connection.')
      except Exception as e:
        log('ERROR', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
    return


def case_convert(name):
  string = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
  return re.sub('([a-z0-9])([A-Z])', r'\1_\2', string).lower()


def device_info(device):
  retval = str()
  for key in device:
    if retval:
      retval = retval + ','
    retval = retval + case_convert(key) + '="' + str(device[key]) + '"'
  return retval


def do_stuff(device, name, obj):
  retval = str()
  if isinstance(obj, dict):
    for each in obj:
      retval = retval + do_stuff(device, each, obj[each])
  if isinstance(obj, (int, bool)):
    if name not in device:
      retval = retval + '# HELP tcc_{0} Total_Control_Comfort value {1}\n'.format(case_convert(name), name)
      retval = retval + '# TYPE tcc_{0} gauge\n'.format(case_convert(name))
      retval = retval + 'tcc_{0}{{{1}}} {2}\n'.format(case_convert(name), device_info(device), int(obj))
  return retval
  

def log(level, *message):
  # If we were called with a descriptive string, find the index.
  if isinstance(level, str):
    level = LOGLEVELS.index(level)
  # TCC_LOGLEVEL can be either a text or a number.
  if os.environ.get('TCC_LOGLEVEL').isdigit():
    debug_level = int(os.environ.get('TCC_LOGLEVEL'))
  else:
    debug_level = LOGLEVELS.index(os.environ.get('TCC_LOGLEVEL'))
  if (level <= debug_level):
    print("[{0}] {1}".format(LOGLEVELS[level], " ".join(message)))


def main():
  global client, devices
  log('DEBUG', 'TCC portal username: {0}'.format(os.environ.get('TCC_USERNAME')))
  log('DEBUG', 'TCC portal password: {0}'.format(os.environ.get('TCC_PASSWORD')))
  client = Client(os.environ.get('TCC_USERNAME'), os.environ.get('TCC_PASSWORD'))
  try:
    for location in client.locations():
      for device in location['Devices']:
        log('DEBUG', 'DeviceID: {0}, LocationID: {1}, MacID: {2}, Name: {3}'.format(device['DeviceID'],device['LocationID'],device['MacID'],device['Name']))
        devices.append({ 'DeviceID': device['DeviceID'], 'LocationID': device['LocationID'], 'MacID': device['MacID'], 'Name': device['Name'] })
  except TypeError as e:
    log('CRITICAL', 'Failed to collect our list of known locations and devices. Aborting.')
    return
  except Exception as e:
    log('CRITICAL', '{0} {1}: {2!r}'.format(inspect.currentframe().f_code.co_name, type(e).__name__, e.args))
    return
  httpd = HTTPServer(('', int(os.environ.get('TCC_EXPORTER_PORT'))), Server)
  log('DEBUG', 'Starting HTTP server on port {0}'.format(os.environ.get('TCC_EXPORTER_PORT')))
  httpd.serve_forever()


if __name__ == '__main__':
  log('INFO', 'Started tcc-exporter/'+VERSION)
  main()

